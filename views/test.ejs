<!DOCTYPE html>
<html lang="zh-Hant">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0"><!-- name å±¬æ€§ æ˜¯ç”¨ä¾†å‘Šè¨´ç€è¦½å™¨ï¼Œé€™å€‹ <meta> æ¨™ç±¤çš„ç”¨é€”æ˜¯ä»€éº¼ã€‚  -->
  <title> speed</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ğŸ§‹</text></svg>">
  <style>
    /* html æ˜¯æ•´å€‹æˆ¿å­çš„æœ€å¤–ç‰†

body æ˜¯æˆ¿å­è£¡é¢çš„ä¸»è¦æˆ¿é–“ */
    body,
    html {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #f8e2cc;
      font-family: sans-serif;
    }

    canvas {
      display: block;
      /* å› ç‚º canvas é è¨­æ˜¯ inlineï¼ˆåƒæ–‡å­—ï¼‰åŠ ä¸Š display: block æ‰èƒ½é¿å…å®ƒä¸‹é¢å‡ºç¾å¥‡æ€ªç©ºç™½ã€‚
    inline å…ƒç´ æœƒï¼šå’Œæ–‡å­—ä¸€æ¨£æ’åœ¨è¡Œå…§ï¼Œä¸‹æ–¹æœƒæœ‰ â€œåŸºç·šç©ºç™½â€ï¼ˆå› ç‚ºæ“ºå­—çš„ç©ºé–“ï¼‰ */
    }
  </style>
</head>

<body>

  <canvas id="intro"></canvas>

  <script>
    const canvas = document.getElementById('intro');
    const ctx = canvas.getContext('2d'); /* å¾ç•«å¸ƒå–å¾—èƒ½é€²è¡Œ 2D ç¹ªåœ–çš„ã€Œç•«ç­†å·¥å…·ã€ */
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    /* æŠŠ canvas çš„å¤§å°è¨­å®šæˆè·Ÿç€è¦½å™¨è¦–çª—ä¸€æ¨£å¤§ï¼Œè®“å®ƒè®Šæˆå…¨è¢å¹•ç•«å¸ƒ */

    const centerX = canvas.width / 2; /* è¨ˆç®—ç•«å¸ƒçš„ä¸­å¿ƒé» X åº§æ¨™ */
    const centerY = canvas.height / 2; /* è¨ˆç®—ç•«å¸ƒçš„ä¸­å¿ƒé» Y åº§æ¨™ */


    const strawberryPattern = [
      [-2, -3, 'green'], [-1, -3, 'green'], [0, -3, 'green'], [1, -3, 'green'], [2, -3, 'green'],
      [-3, -2, 'green'], [-2, -2, 'red'], [-1, -2, 'red'], [0, -2, 'red'], [1, -2, 'red'],
      [2, -2, 'red'], [3, -2, 'green'], [-4, -1, 'red'], [-3, -1, 'red'], [-2, -1, 'red'],
      [-1, -1, 'red'], [0, -1, 'red'], [1, -1, 'red'], [2, -1, 'red'], [3, -1, 'red'],
      [4, -1, 'red'], [-4, 0, 'red'], [-3, 0, 'red'], [-2, 0, 'red'], [-1, 0, 'red'],
      [0, 0, 'red'], [1, 0, 'red'], [2, 0, 'red'], [3, 0, 'red'], [4, 0, 'red'],
      [-3, 1, 'red'], [-2, 1, 'red'], [-1, 1, 'red'], [0, 1, 'red'], [1, 1, 'red'],
      [2, 1, 'red'], [3, 1, 'red'], [-2, 2, 'red'], [-1, 2, 'red'], [0, 2, 'red'],
      [1, 2, 'red'], [2, 2, 'red'], [-1, 3, 'red'], [0, 3, 'red'], [1, 3, 'red'],
      [0, 4, 'red'], [-1, 0, 'white'], [1, 0, 'white'], [0, 1, 'white']
    ]; /* é€™é‚Šåªæ˜¯å¯«å‡ºèªª é€™éº¼å¤šå€‹é™£åˆ—å¯ä»¥çµ„åˆæˆè‰è“çš„åœ–æ¡ˆå° */

    /* é€™å€‹é™£åˆ—æ¯å€‹å…ƒç´ è¦ ä¸‰å€‹å€¼ [x, y, color]ï¼ŒåŸå› å¾ˆç›´æ¥ï¼š
    
    x åº§æ¨™ï¼šæ±ºå®šé€™å€‹é»åœ¨æ°´å¹³çš„ä½ç½®ï¼ˆå·¦å³ï¼‰ã€‚
    
    y åº§æ¨™ï¼šæ±ºå®šé€™å€‹é»åœ¨å‚ç›´çš„ä½ç½®ï¼ˆä¸Š+9ä¸‹ï¼‰ã€‚
    
    color é¡è‰²ï¼šæ±ºå®šé€™å€‹é»è¦ç•«æˆä»€éº¼é¡è‰²ï¼ˆç¶ è‰²è‘‰å­ã€ç´…è‰²æœå¯¦ã€ç™½è‰²é«˜å…‰ï¼‰ã€‚ */

    const speedPattern = [];
    const letterMap = {
      S: ["1110", "1000", "1110", "0010", "1110"],
      P: ["110", "101", "110", "100", "100"],
      E: ["111", "100", "111", "100", "111"],
      D: ["110", "101", "101", "101", "110"] // ä¿ç•™ D å½¢ç‹€
    };

    function createLetterPattern(letter, offsetX) {
      const pattern = [];
      const rows = letterMap[letter];
      rows.forEach((row, y) => {
        row.split('').forEach((v, x) => {
          if (v === '1') pattern.push([x + offsetX, y, 'white']);
        });
      });
      return pattern;
    }

    let offset = 0;
    ['S', 'P', 'E', 'E', 'D'].forEach(l => {
      const letterPattern = createLetterPattern(l, offset);
      speedPattern.push(...letterPattern);
      offset += (letterMap[l][0].length + 1);
    });

    /* return çš„æ„æ€æ˜¯ æŠŠé€™å€‹å‡½å¼è™•ç†å¾Œçš„çµæœã€Œå›å‚³ã€å‡ºå» */
    let blocks = strawberryPattern.map(p => {
      return {
        x: Math.random() * canvas.width,
        y: Math.random() * canvas.height,
        targetX: centerX + p[0] * 25, /* æ–¹å¡Š 20px + å¤–åŠ  5px é–“éš” = 25px */
        targetY: centerY + p[1] * 25,
        size: 20,
        color: p[2],
        angle: Math.random() * Math.PI * 2, /* éš¨æ©Ÿåˆå§‹è§’åº¦ */
        angularVel: (Math.random() - 0.5) * 0.05,
        floatOffset: Math.random() * Math.PI * 2
      };
    });

    let frame = 0;
    let stage = 1; // 1: è‰è“, 2: è‰è“æ·¡å‡º â†’ SPEEDæ‹¼åˆ, 3: SPEEDåœç•™

    function animate() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      if (stage === 1) {
        blocks.forEach(b => {
          if (frame < 60) {
            b.x += (Math.random() - 0.5) * 5;
            b.y += (Math.random() - 0.5) * 5;
          } else {
            b.x += (b.targetX - b.x) * 0.07;
            b.y += (b.targetY - b.y) * 0.07;
            b.angle += b.angularVel;
            b.y += Math.sin(frame * 0.05 + b.floatOffset) * 0.3;
          }
          ctx.save();
          ctx.translate(b.x, b.y);
          ctx.rotate(b.angle);
          ctx.fillStyle = b.color;
          ctx.fillRect(-b.size / 2, -b.size / 2, b.size, b.size);
          ctx.restore();
        });

        frame++;
        if (frame > 150) {
          stage = 2;

          // --- ç¢ºä¿ SPEED æ¯æ ¼éƒ½æœ‰å°æ‡‰ block ---
          // å¦‚æœ blocks ä¸å¤ å¤šï¼Œå°±è£œè¶³
          while (blocks.length < speedPattern.length) {
            blocks.push({
              x: Math.random() * canvas.width,
              y: Math.random() * canvas.height,
              size: 20,
              color: 'white',
              angle: Math.random() * Math.PI * 2,
              angularVel: (Math.random() - 0.5) * 0.05,
              floatOffset: Math.random() * Math.PI * 2
            });
          }

          // è¨ˆç®— SPEED targetY ç½®ä¸­ä¸”åº•éƒ¨å°é½Š
          const ys = speedPattern.map(p => p[1]);
          const minY = Math.min(...ys);
          const maxY = Math.max(...ys);
          const totalHeight = maxY - minY + 1;

          blocks.forEach((b, i) => {
            const target = speedPattern[i % speedPattern.length];
            b.targetX = centerX + (target[0] - offset / 2) * 25;
            b.targetY = centerY + (target[1] - minY - (totalHeight - 1) / 2) * 25;
            b.color = target[2];
          });

          frame = 0;
        }

      } else if (stage === 2) {
        blocks.forEach(b => {
          b.x += (b.targetX - b.x) * 0.07;
          b.y += (b.targetY - b.y) * 0.07;
          b.angle += b.angularVel * 0.2;

          ctx.save();
          ctx.translate(b.x, b.y);
          ctx.rotate(b.angle);
          ctx.fillStyle = b.color;
          ctx.fillRect(-b.size / 2, -b.size / 2, b.size, b.size);
          ctx.restore();
        });

        frame++;
        if (frame > 120) {
          stage = 3;
          frame = 0;
        }

      } else if (stage === 3) {
        blocks.forEach(b => {
          ctx.save();
          ctx.translate(b.x, b.y);
          ctx.rotate(b.angle * 0.1);
          ctx.fillStyle = b.color;
          ctx.fillRect(-b.size / 2, -b.size / 2, b.size, b.size);
          ctx.restore();
        });

        frame++;
        if (frame > 240) showContent();
      }

      requestAnimationFrame(animate);
    }

    // --- å‹•ç•«çµæŸå¾Œç›´æ¥è·³åˆ° homepage.html ---
    function showContent() {
      window.location.href = "/homepage";
    }

    animate();
  </script>

</body>

</html>